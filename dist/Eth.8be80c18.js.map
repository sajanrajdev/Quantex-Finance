{"version":3,"sources":["../src/utils.js","../src/Eth.js"],"names":["defer","resolve","reject","promise","Promise","success","failure","splitPath","path","result","components","split","forEach","element","number","parseInt","isNaN","length","push","eachSeries","arr","fun","reduce","p","e","then","foreach","callback","iterate","index","array","res","doIf","condition","asyncWhile","predicate","starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","hexBuffer","str","Buffer","from","startsWith","slice","maybeHexBuffer","remapTransactionRelatedErrors","statusCode","EthAppPleaseEnableContractData","Eth","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","boolDisplay","boolChaincode","paths","buffer","alloc","writeUInt32BE","send","response","publicKeyLength","addressLength","publicKey","toString","address","chainCode","provideERC20TokenInformation","data","signTransaction","rawTxHex","offset","rawTx","toSend","rlpTx","decode","rlpOffset","chainIdPrefix","rlpVrs","encode","chainIdSrc","chainIdBuf","copy","readUInt32BE","maxChunkSize","chunkSize","i","apduResponse","v","r","s","getAppConfiguration","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","starkv2Supported","version","signPersonalMessage","messageHex","message","signEIP712HashedMessage","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","starkGetPublicKey","starkSignOrder","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","starkSignOrder_v2","sourceQuantizationType","sourceMintableBlobOrTokenId","destinationQuantizationType","destinationMintableBlobOrTokenId","Error","starkSignTransfer","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","starkSignTransfer_v2","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferAddress","conditionalTransferFact","conditionalTransferAddressHex","starkProvideQuantum","operationContract","operationQuantization","operationContractHex","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hash","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex","withdrawalIndex"],"mappings":"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","file":"Eth.8be80c18.js","sourceRoot":"..\\src","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: (T) => void,\n  reject: (any) => void,\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach((element) => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: (A) => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function (res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then((res) => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nexport type StarkQuantizationType =\n  | \"eth\"\n  | \"erc20\"\n  | \"erc721\"\n  | \"erc20mintable\"\n  | \"erc721mintable\";\n\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nfunction hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str: ?string): ?Buffer {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    // Check if the TX is encoded following EIP 155\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2)\n        .toString(16)\n        .slice(0, -2); // Drop the low byte, that comes from the ledger.\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    erc20ProvisioningNecessary: number,\n    starkEnabled: number,\n    starkv2Supported: number,\n    version: string,\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response) => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n      .then((response) => {\n        const v = response[0];\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 32;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      destinationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x01, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization?: BigNumber,\n    sourceMintableBlobOrTokenId?: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization?: BigNumber,\n    destinationMintableBlobOrTokenId?: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" +\n          sourceQuantizationType\n      );\n    }\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" +\n          destinationQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        1 +\n        20 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        8 +\n        4 +\n        4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (sourceQuantization) {\n      Buffer.from(\n        sourceQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(\n        sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (destinationQuantization) {\n      Buffer.from(\n        destinationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(\n        destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x03, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      transferQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x02, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization?: BigNumber,\n    transferMintableBlobOrTokenId?: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(\n      conditionalTransferAddress\n    );\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" +\n          transferQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (transferQuantization) {\n      Buffer.from(\n        transferQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(\n        transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(\n        conditionalTransferFact.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x04,\n        conditionalTransferAddressHex ? 0x05 : 0x04,\n        0x00,\n        buffer\n      )\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract?: string,\n    operationQuantization: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n    Buffer.from(\n      operationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract?: string,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" +\n          operationQuantizationType\n      );\n    }\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (operationQuantization) {\n      Buffer.from(\n        operationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(\n        operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x08,\n        starkQuantizationTypeMap[operationQuantizationType],\n        0x00,\n        buffer\n      )\n      .then(\n        () => true,\n        (e) => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n          throw e;\n        }\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer> {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport\n      .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        result.publicKey = response.slice(0, -2).toString(\"hex\");\n        return result;\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n}\n"]}