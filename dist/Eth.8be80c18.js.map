{"version":3,"sources":["../src/utils.js","../src/Eth.js","../node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["defer","resolve","reject","promise","Promise","success","failure","splitPath","path","result","components","split","forEach","element","number","parseInt","isNaN","length","push","eachSeries","arr","fun","reduce","p","e","then","foreach","callback","iterate","index","array","res","doIf","condition","asyncWhile","predicate","starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","hexBuffer","str","Buffer","from","startsWith","slice","maybeHexBuffer","remapTransactionRelatedErrors","statusCode","EthAppPleaseEnableContractData","Eth","constructor","transport","scrambleKey","decorateAppAPIMethods","getAddress","boolDisplay","boolChaincode","paths","buffer","alloc","writeUInt32BE","send","response","publicKeyLength","addressLength","publicKey","toString","address","chainCode","provideERC20TokenInformation","data","signTransaction","rawTxHex","offset","rawTx","toSend","rlpTx","decode","rlpOffset","chainIdPrefix","rlpVrs","encode","chainIdSrc","chainIdBuf","copy","readUInt32BE","maxChunkSize","chunkSize","i","apduResponse","v","r","s","getAppConfiguration","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","starkv2Supported","version","signPersonalMessage","messageHex","message","signEIP712HashedMessage","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","starkGetPublicKey","starkSignOrder","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","padStart","starkSignOrder_v2","sourceQuantizationType","sourceMintableBlobOrTokenId","destinationQuantizationType","destinationMintableBlobOrTokenId","Error","starkSignTransfer","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","starkSignTransfer_v2","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferAddress","conditionalTransferFact","conditionalTransferAddressHex","starkProvideQuantum","operationContract","operationQuantization","operationContractHex","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hash","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex","withdrawalIndex","OVERLAY_ID","OldModule","module","bundle","Module","moduleName","call","hot","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","type","handled","assets","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","console","clear","hmrApply","hmrAcceptRun","reload","close","onclose","log","removeErrorOverlay","error","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","concat","Function","deps","cached","cache","some","cb"],"mappings":"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","file":"Eth.8be80c18.js","sourceRoot":"..\\src","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: (T) => void,\n  reject: (any) => void,\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach((element) => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: (A) => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function (res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then((res) => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nexport type StarkQuantizationType =\n  | \"eth\"\n  | \"erc20\"\n  | \"erc721\"\n  | \"erc20mintable\"\n  | \"erc721mintable\";\n\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nfunction hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str: ?string): ?Buffer {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    // Check if the TX is encoded following EIP 155\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2)\n        .toString(16)\n        .slice(0, -2); // Drop the low byte, that comes from the ledger.\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    erc20ProvisioningNecessary: number,\n    starkEnabled: number,\n    starkv2Supported: number,\n    version: string,\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response) => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n      .then((response) => {\n        const v = response[0];\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 32;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      destinationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x01, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization?: BigNumber,\n    sourceMintableBlobOrTokenId?: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization?: BigNumber,\n    destinationMintableBlobOrTokenId?: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" +\n          sourceQuantizationType\n      );\n    }\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" +\n          destinationQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        1 +\n        20 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        8 +\n        4 +\n        4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (sourceQuantization) {\n      Buffer.from(\n        sourceQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(\n        sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (destinationQuantization) {\n      Buffer.from(\n        destinationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(\n        destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x03, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      transferQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x02, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization?: BigNumber,\n    transferMintableBlobOrTokenId?: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(\n      conditionalTransferAddress\n    );\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" +\n          transferQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (transferQuantization) {\n      Buffer.from(\n        transferQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(\n        transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(\n        conditionalTransferFact.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x04,\n        conditionalTransferAddressHex ? 0x05 : 0x04,\n        0x00,\n        buffer\n      )\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract?: string,\n    operationQuantization: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n    Buffer.from(\n      operationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract?: string,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" +\n          operationQuantizationType\n      );\n    }\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (operationQuantization) {\n      Buffer.from(\n        operationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(\n        operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x08,\n        starkQuantizationTypeMap[operationQuantizationType],\n        0x00,\n        buffer\n      )\n      .then(\n        () => true,\n        (e) => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n          throw e;\n        }\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer> {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport\n      .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        result.publicKey = response.slice(0, -2).toString(\"hex\");\n        return result;\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n}\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else if (location.reload) { // `location` global exists in a web worker context but lacks `.reload()` function.\n        location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}