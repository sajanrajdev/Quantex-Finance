{"version":3,"sources":["../node_modules/u2f-api/lib/google-u2f-api.js","../node_modules/u2f-api/lib/u2f-api.js","../node_modules/u2f-api/index.js","../src/Transport.js","../src/index.js","../src/TransportU2F.js"],"names":["Transport","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","EventEmitter","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","StatusCodes","OK","length","TransportError","response","exchange","concat","from","sw","readUInt16BE","some","s","TransportStatusError","exchangeBusyPromise","exchangeAtomicImpl","f","TransportRaceCondition","resolveBusy","busyPromise","Promise","r","unresponsiveReached","timeout","setTimeout","emit","res","clearTimeout","_appAPIlock","_apdu","Error","setScrambleKey","_key","close","resolve","on","eventName","cb","off","removeListener","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","next","e","unsubscribe","listenTimeoutId","open","descriptor","then","error","complete","ErrorMessage_NoDeviceFound","ErrorMessage_ListenTimeout","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","apply","isSupported","list","id","subscribers","log","type","message","obj","String","date","Date","dispatch","push","i","indexOf","pop","window","__ledgerLogsListen","wrapU2FTransportError","originalError","err","wrapApdu","apdu","key","result","webSafe64","base64","replace","normal64","substring","attemptExchange","timeoutMillis","unwrap","keyHandle","challenge","signRequest","version","toString","appId","location","origin","sign","signatureData","slice","transportInstances","emitDisconnect","forEach","t","isTimeoutU2FError","u2fError","metaData","code","TransportU2F","_","_openTimeout","constructor","isU2FError","setUnwrap","supported","observer","unsubscribed"],"mappings":"AEAA,AFAA;AECA,AFAA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA,AGJA;AJMA,ACDA,AILA,ADCA;AJMA,ACDA,AGJA;AJMA,ACDA,AINA,ADYA,IAAIyF,EAAE,GAAG,CAAT;AJJA,ACDA,AGMA,MAAMC,WAAW,GAAG,EAApB;AJJA,ACDA,AIPA,ADcA;AJLA,ACDA,AGOA;AJLA,ACDA,AIRA,ADeA;AJLA,ACDA,AGOA;AJLA,ACDA,AGOA;AJLA,ACDA;ADEA,ACDA,AIVA,ADgBO,MAAMC,GChBJc,ADgBO,GAAG,CAACb,IAAD,EAAeC,OAAf,EAAiClF,EChBpD,CAA+B+F,CDgBZ,KAAgD,OChBnE,EAA8Cb,OAA9C,EAAuDJ,EAAvD,EAA2D;ALY3D,ACDA,AIVE,ADgBA,QChBMkB,ADgBAb,GChBG,ADgBK,GChBF,ADgBK,IChBD5E,sBAAJ,CAAmB2E,OAAnB,EAA4BJ,EAA5B,CAAZ,CADyD,CAEzD;ALWF,ACDA,AGKqBG,IAAAA,IAAF;AJHnB,ACDA,AIVEe,ADcyBlB,ECdzBkB,EDcyBlB,CCdtB,CAACiB,ADcuB,EAAEX,MAAM,CAAC,EAAEN,ECdtCkB,ADcmC,CAAlB,ECdGD,aAApBC;ALYF,ACDA,AIVE,ADa2CX,IAAAA,IAAI,CCbxCW,CDa0C,ECbjD,EDaqDV,IAAJ;AJDnD,ACDA,AIVC,ADYkB,GAAjB;AJAF,ACDA,AGEE,MAAIJ,OAAJ,EAAaC,GAAG,CAACD,OAAJC,GAAcD,OAAdC;AJAf,ACDA,AIVA,ADYE,MAAInF,GCZGiG,CDYP,EAAUd,GAAG,CAACnF,CCZhB,CAAkBkG,EDYNf,ECZZ,CDYuBnF,CCZSmG,GAAhC,ADYYhB,ECZiC;ALY7C,ACDA,AIVE,ADYAI,EAAAA,MCZMa,EDYE,CAACjB,GCZG,ADYJ,CAARI,ECZetF,MAAM,CAACC,KAAPD,CAAaiG,IAAI,CAAC5F,MAAlBL,CAAf;ALYF,ACDA,AGHO,CAAA;AJKP,ACDA,AIXE,ADcF,OCdO,IAAIwF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,IAAI,CAAC5F,MAAzB,EAAiCmF,CAAC,EAAlC,EAAsC;ALaxC,ACDA,AIXIW,ADcJ,ICdIA,MAAM,CAACX,CAAD,CAANW,GAAYF,IAAI,CAACT,CAAD,CAAJS,GAAUC,GAAG,CAACV,CAAC,GAAGU,GAAG,CAAC7F,MAAT,CAAzB8F;ALaJ,ACDA,AIXG,ADcH;AJDA,ACDA,AGGA;AJDA,ACDA,AE7BA,AEiBE,ADeF,SCfSA,MAAP;ALcF,ACDA,EIVA;ALYA,ACDA,AE7BA;AH+BA,ACDA;ADEA,ACDA,AIZA,MAAMC,SAAS,GAAIC,MAAD,IAChBA,MAAM,CAACC,OAAPD,CAAe,KAAfA,EAAsB,GAAtBA,EAA2BC,OAA3BD,CAAmC,KAAnCA,EAA0C,GAA1CA,EAA+CC,OAA/CD,CAAuD,KAAvDA,EAA8D,EAA9DA,CADF,EAGA;ALWA,ACDA,AGDO,MAAM9C,MAAM,GAAIhB,EAAD,IAAoC;AJG1D,ACDA,AElBA,ACiBEuC,EAAAA,WAAW,CAACS,IAAZT,CAAiBvC,EAAjBuC;AJGF,ACDA,AElBA,AEOA,ADUE,MCVIyB,GDUG,KCVK,CDUC,ECVGF,MAAD,IACfA,MAAM,CAACC,OAAPD,CAAe,IAAfA,EAAqB,GAArBA,EAA0BC,OAA1BD,CAAkC,IAAlCA,EAAwC,GAAxCA,IACA,KAAKG,SAAL,CAAe,CAAf,EAAmB,IAAIH,MAAM,CAAChG,MAAX,GAAqB,CAAxC,CAFF;ALaA,ACDA,AGDI,UAAMmF,CAAC,GAAGV,WAAW,CAACW,OAAZX,CAAoBvC,EAApBuC,CAAV;AJGJ,ACDA,AEOA,AEhBA,SAAS2B,eAAT,CACER,IADF,EAEES,aAFF,EAGEpC,WAHF,EAIEqC,MAJF,EAKmB;ALMnB,ACDA,AEOA,AEXE,ADEE,QCFIC,ADEApB,CAAC,KAAK,CAAC,CAAX,CCFa,CDEC,ECFEQ,QAAQ,CAACC,IAAD,EAAO3B,WAAP,CAA1B;ALMF,ACDA,AEOA,AEXE,ADEI,QCFEuC,SAAS,GAAG7G,MAAM,CAACU,IAAPV,CAChB,kEADgBA,EAEhB,KAFgBA,CAAlB;ALMF,ACDA,AEOA,AERE,ADDI8E,MAAAA,ECCEgC,SDDS,CAACtB,CCCC,ADDF,CAAXV,ECCgB,CDDCA,WAAW,CAACA,WAAW,CAACzE,MAAZyE,GAAqB,CAAtB,CAA5BA;AJIN,ACDA,AEOA,AERIiC,ADDEjC,ICCFiC,EDDEjC,KCCK,EAAE,IDDI,CAACY,GCAI,ADAhBZ;AJIN,ACDA,AEOe,AERX8B,ADDC,ICCDA,EFQiBxH,OERR,EFQE,AERAgH,CFQ4B,QERnB,CAACQ,SAAS,CAACI,QAAVJ,CAAmB,QAAnBA,CAAD,CAFF;ALKtB,ACDA,AEM2C,AEPvCC,ADRF,EDeyC,CCfzC,CCQEA,SFOuC,AEP9B,EAAET,CFO4B,QEPnB,CAACS,SAAS,CAACG,QAAVH,CAAmB,QAAnBA,CAAD,CAHF;ALMtB,ACDA,AEK2C,AENvCI,ADXG,CAAA,GCWHA,KFOF5H,AEPO,EAAE6H,QAAQ,CAACC,IFMuB,GACf,KADe;AHH3C,ACDA,AEI2C,AEVrB,GAApB,MFYA7H,mBAFyC,GAEX,KAFW;AHF3C,ACDA,AEG2C,AEJzCyF,SFOAxF,QEPI,GFIqC,GAGb,AEP5BwF,EAAY,EFI6B,MEJrBkB,IAAI,CAACe,QAALf,CAAc,KAAdA,CAApBlB;ALGF,ACDA,AEE2C,AEHzC,SFoFAvF,AEpFO4H,OFGkC,GAiF/B,IAAI3H,IEpFFqH,WFoFF,AEpFHM,EFGkC,AEHhBV,aAAa,GAAG,IAAlCU,EAAwCtD,IAAxCsD,CAA8C7G,QAAD,IAAc;ALGpE,ACDA,AIDI,ADHJ,SAAS+E,CCGC,ODHV,CAAkBP,GAAlB,EAA4B;AJM5B,ACDA,AEA2C,AEF/BsC,ADFV,MCEUA,CDFL,ED4IL3H,EC5IS8F,CAAC,CDI+B,ECJ5B,CD4IN,AC5IP,EAAgBA,CAAC,GAAGV,CD6IlBnF,GADK,EAELC,GAFK,EAGLC,AC/I6B,CAACQ,CD4IzB,EAILP,EAJK,CC5IP,CDiJEC,CCjJsCyF,CAAC,EDiJ3B,ACjJd,EAA6C,CDiJ5BxF,MAAM,CAACC,KAAPD,CAAa,CAAbA,CALV,EAMLE,UAAyB,GAAG,CAACC,oBAAYC,EAAb,CANvB,KAOe;AH7IxB,ACDA,AE+II,AElJM,ADDN,QCC0BG,ADDtB,EDmJAR,IAAI,CAACM,CElJT,KFkJIN,IAAe,GAAnB,EAAwB;AH7I5B,ACDA,AE+IM,ACnJA+E,MAAAA,QDmJM,GCnJK,CDmJDxE,ACnJEkF,CAAD,CAAXV,CAAeC,GAAfD,gBDmJM,CACJ,8CAA8C/E,IAAI,CAACM,MAD/C,EAEJ,kBAFI,CAAN;AH7IN,ACDA,AEkJK,AEtJD,ADFA,KAAA,CAEE,ECAE,KDAKoD,CAAP,CCAS4D,CDAC,YCAR,KAAyB,QAA7B,EAAuC;ALM3C,ACDA,AIJM,ADAAxE,MAAAA,MCAM9C,CDAC,CAACgE,ECAE,GAAG/D,ADAb6C,CAAcY,CAAdZ,ICAmB,CAACnC,IAAPV,CAAYuG,QAAQ,CAACc,aAAD,CAApBrH,EAAqC,QAArCA,CAAb;ALMN,ACDA,AEiJI,AErJE,ADAD,UCAKmG,EFqJA5F,IErJJ,IFqJY,GAAG,MAAM,KAAKC,QAAL,CACrBR,MAAM,CAACS,MAAPT,CAAc,CACZA,MAAM,CAACU,IAAPV,CAAY,CAACL,GAAD,EAAMC,GAAN,EAAWC,EAAX,EAAeC,EAAf,CAAZE,CADY,EAEZA,MAAM,CAACU,IAAPV,CAAY,CAACD,IAAI,CAACM,MAAN,CAAZL,CAFY,EAGZD,IAHY,CAAdC,CADqB,CAAvB;AH/IJ,ACDA,AEuJI,AC3JD,YD2JOW,EAAE,GAAGJ,QAAQ,CAACK,YAATL,CAAsBA,QAAQ,CAACF,MAATE,GAAkB,CAAxCA,CAAX;AHrJJ,ACDA,AILM,EDGN,QCHU,CAACoG,MAAL,EAAa;ALOnB,ACDA,AEsJI,AE3JIR,QAAAA,EF2JA,CAACjG,GE3JK,GAAGH,IF2JE,AE3JXoG,CF2JYtF,IAAXX,CAAiBY,CAAD,IAAOA,CAAC,KAAKH,EAA7BT,CAAL,EAAuC;AHpJ3C,ACDA,AEsJM,AE7JA,OAAA,MAEO,CF2JD,IAAIa,4BAAJ,CAAyBJ,EAAzB,CAAN;AHpJN,ACDA,AEsJK,AE3JGwF,ADCR,IAAI,ICDIA,GDCGR,GCDG,GAAG5F,ADCb,ICDiB,CAACuH,ADCA,KCDLvH,CAAW,CAAXA,CAAToG,GDCR,EAAmC;AJMnC,ACDA,AILO,ADCLR,EAAAA,MAAM,CAACC,kBAAPD,GAA4BpC,MAA5BoC;AJMF,ACDA,AEqJI,ACzJH,aDyJUpF,QAAP;AHnJJ,ACDA,AEb2C,AEOrCwE,KFPqC,gBEOjC,MAAJA,EAAY,QAAQoB,MAAM,CAACa,QAAPb,CAAgB,KAAhBA,CAApBpB;ALQN,ACDA,AINM,aAAOoB,MAAP;ALQN,ACDA,AEf2C,AEDvC,KAAA,IFuNFnF,EE7MS,iBFTgC,GAAA,KAAA,CAAA;AHiB3C,ACDA,AINM,YAAMT,QAAN;ALQN,ACDA,AEjB2C,AEWtC,SF8MHU,kBAzNyC,GAyNpB,MAAOC,CAAP,IAAa;AHtMpC,ACDA,AEwMI,AE7NK,GAAAkG,CAAP,MF6NM,KAAKpG,mBAAT,EAA8B;AHtMlC,ACDA,AEwMM,AE9ML,cF8MW,IAAIG,8BAAJ,CACJ,+EADI,CAAN;AHtMN,ACDA,AE0MK;AHxML,ACDA,AINA,IAAIoG,kBAAkB,GAAG,EAAzB;ALQA,ACDA,AEyMI,UAAInG,WAAJ;AHvMJ,ACDA,AEyMI,AE/MJ,SAASoG,GF+MCnG,WAAW,AE/MrB,GF+MwB,AE/ME,IF+MEC,OAAJ,CAAaC,CAAD,IAAO;AHvM3C,ACDA,AEyMMH,AE/MJmG,EAAAA,MF+MInG,WAAW,CE/MG,CAACqG,CF+MDlG,CAAdH,KE/MJmG,CAA4BG,CAAD,IAAOA,CAAC,CAAC/F,IAAF+F,CAAO,YAAPA,CAAlCH;ALQF,ACDA,AEuMwB,AE7MtBA,EAAAA,KF6MsB,CAApB,YE7MgB,GAAG,EAArBA;ALQF,ACDA,AEyMI,AE/MH,WF+MQvG,mBAAL,GAA2BK,WAA3B;AHvMJ,ACDA,AEyMI,UAAIG,mBAAmB,GAAG,KAA1B;AHvMJ,ACDA,AEyMI,AE/MJ,SAASmG,GF+MClG,OAAO,GAAGC,IE/MpB,CAA2BkG,KF+MG,CAAC,EE/M/B,EAAqC,EF+MA;AHvMrC,ACDA,AEyMMpG,AE/MJ,QF+MIA,CE/MGoG,QAAQ,CAACC,QAATD,CF+MgB,AE/MEE,GF+MC,CE/MnBF,GF+MHpG,EE/M8B,CAAlC;ALQF,ACDA,AEyMM,AE/ML,aF+MUG,IAAL,CAAU,cAAV;AHvMN,ACDA,AEsM8B,AE3M9B,OF2M8B,EAGvB,KAAKrC,mBAHkB,CAA1B;AHpMJ,ACDA,AILA;ALOA,ACDA,AEwMI,AE7MJ,UF6MQ;AHtMR,ACDA,AEwMM,AE7MN,cF6MYsC,GAAG,GAAG,MAAMV,CAAC,EAAnB;AHtMN,ACDA,AILA;ALOA,ACDA,AEuMM,AE5MN,YF4MUM,mBAAJ,EAAyB;AHrM/B,ACDA,AEuMQ,AE5MR,eF4MaG,IAAL,CAAU,YAAV;AHrMR,ACDA,AEuMO;AHrMP,ACDA;ADEA,ACDA,AEsMM,AE7MS,MAAMoG,SF6MRnG,GAAP,AE7MS,SAA2BxC,oBAA3B,CAA2C;ALS1D,ACDA,AEgMI,AErMF,OFqME,SAMU;AHpMd,ACDA,AEsMMyC,AE3MN,QF2MMA,YAAY,CAACJ,OAAD,CAAZI;AHpMN,ACDA,AEsMM,YAAIT,WAAJ,EAAiBA,WAAW;AHpMlC,ACDA,AEsMM,AExMJ,aFwMSJ,mBAAL,GAA2B,IAA3B;AHpMN,ACDA,AEsMK,AExML;ALIA,ACDA,AE9C2C,KAAA;AHgD3C,ACDA,AI0BE;ALxBF,ACDA,AEhD2C,AE0E3C,SF2LEc,WArQyC,GAqQ3B,IArQ2B;AHkD3C,ACDA,AEjD2C,AE2E3C;ALxBA,ACDA,AEKE,AEqBA,eAAa8B,IAAb,CAAkBoE,CAAlB,EAAwBC,YAAqB,GAAG,IAAhD,EAA6E;ALxB/E,ACDA,AEKA,AEqBI,WAAO,IAAIF,YAAJ,EAAP;ALxBJ,ACDA,AEKA,AEqBG;ALxBH,ACDA,AEKA;AHHA,ACDA,AEKA,AEqBEG,EAAAA,WAAW,GAAG;ALxBhB,ACDA,AEKA,AEqBI;ALxBJ,ACDA,AEKA,AEmBgB,SAXd5D,WAWc,GAAA,KAAA,CAAA;ALtBhB,ACDA,AIuBgB,SATdqC,MASc,GATI,IASJ;ALrBhB,ACDA,AIwBIY,IAAAA,kBAAkB,CAAChC,IAAnBgC,CAAwB,IAAxBA;ALtBJ,ACDA,AEGE/G,AEqBC,EFrBDA,QAAQ,CAACuB,KAAD,EAAiC;AHD3C,ACDA,AEGI,AEsBF,UFtBQ,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AHDJ,ACDA,AEGG,AEsBH;ALvBA,ACDA,AEIE,AEqBF;ALvBA,ACDA,AEIA,AEqBA;ALvBA,ACDA,AEIA,AEqBA;ALvBA,ACDA,AEIA;AHFA,ACDA,AEIA;AHFA,ACDA,AIuBE,QAAMxB,QAAN,CAAeyF,IAAf,EAA8C;ALrBhD,ACDA,AIuBI,QAAI;ALrBR,ACDA,AEEEhE,AEqBI,EFrBJA,WEqBW,GFrBG,CAACC,EEqBEuE,EFrBH,EAAe,CAAE,UEqBC,CAC1BR,IAD0B,EAE1B,KAAK5G,eAFqB,EAG1B,KAAKiF,WAHqB,EAI1B,KAAKqC,MAJqB,CAA5B;ALrBN,ACDA,AEGE,AEkBE,KAAA,CAOE,OAAOlD,CAAP,EAAU;AL1BhB,ACDA,AEGA,AEyBM,YAAM0E,UAAU,GAAG,OAAO1E,CAAC,CAACoE,QAAT,KAAsB,QAAzC;AL1BN,ACDA,AEGA;AHDA,ACDA,AEGA,AEwBM,UAAIM,UAAJ,EAAgB;ALzBtB,ACDA,AI2BQ,YAAIR,iBAAiB,CAAClE,CAAD,CAArB,EAA0B;ALzBlC,ACDA,AI2BU+D,UAAAA,cAAc;ALzBxB,ACDA,AECErF,AEuBoB,EFvBpBA,KAAK,EEuBe,CFvBG,AE2BjB;AL1BR,ACDA,AECI,WAAOb,OAAO,CAACc,OAARd,EAAP;AHCJ,ACDA,AECG;AHCH,ACDA,AEIE,AEsBM,cAAMuE,qBAAqB,CACzBpC,CADyB,EAEzB,4CAA4CA,CAAC,CAACoE,QAAFpE,CAAWuB,IAF9B,EAGzB,SAASvB,CAAC,CAACoE,QAAFpE,CAAWqE,IAHK,CAA3B;ALxBR,ACDA,AEIA,AEgBM,OAAA,MAUO;AL5Bb,ACDA,AEIA,AE0BQ,cAAMrE,CAAN;AL5BR,ACDA,AEIA,AE0BO;AL5BP,ACDA,AEIA,AE0BK;AL5BL,ACDA,AI8BG;AL5BH,ACDA,AI+BE;AL7BF,ACDA,AEEEpB,AE6BF,EF7BEA,EAAE,CAACC,SAAD,EAAoBC,EAApB,EAAkC;AHAtC,ACDA,AEEI,SAAK/C,OAAL,CAAa6C,EAAb,CAAgBC,SAAhB,EAA2BC,EAA3B;AHAJ,ACDA,AEEG;AHAH,ACDA,AEGE,AE0BAN,EAAAA,cAAc,CAACqC,WAAD,EAAsB;AL3BtC,ACDA,AEGA,AE0BI,SAAKA,WAAL,GAAmBtE,MAAM,CAACU,IAAPV,CAAYsE,WAAZtE,EAAyB,OAAzBA,CAAnB;AL3BJ,ACDA,AEGA,AE0BG;AL3BH,ACDA,AI8BE;AL5BF,ACDA,AI8BA;AL5BA,ACDA,AECEwC,EAAAA,GAAG,CAACF,SAAD,EAAoBC,EAApB,EAAkC;AHCvC,ACDA,AECI,SAAK/C,OAAL,CAAaiD,cAAb,CAA4BH,SAA5B,EAAuCC,EAAvC;AHCJ,ACDA,AECG,AE2BD6F,EAAAA,SAAS,CAACzB,MAAD,EAAkB;AL1B7B,ACDA,AI4BI,SAAKA,MAAL,GAAcA,MAAd;AL1BJ,ACDA,AECEhF,AE2BC,EF3BDA,IAAI,CAACe,KAAD,EAAgB,GAAGC,IAAnB,EAA4B;AHClC,ACDA,AECI,SAAKnD,OAAL,CAAamC,IAAb,CAAkBe,KAAlB,EAAyB,GAAGC,IAA5B;AHCJ,ACDA,AECG,AE2BDR,EAAAA,KAAK,GAAkB;AL1BzB,ACDA,AEEE,AE0BE;AL1BJ,ACDA,AEEA,AE0BI,WAAOb,OAAO,CAACc,OAARd,EAAP;AL1BJ,ACDA,AEEA,AE0BG;AL1BH,ACDA;ADEA,ACDA,AIxE0D;AL0E1D,ACDA,AEAEsB,EAAAA,YAAY,GAAG;AHEjB,ACDA,AEAIC,IAAAA,OAAO,CAACC,IAARD,CACE,8FADFA;AHEJ,ACDA,AEEG,AE7EkBkF,aACZpD,WADYoD,GACEpD,mBADFoD;AL6ErB,ACDA,AEGE;AHDF,ACDA,AEGA,AEhFqBA,aAKZnD,IALYmD,GAKL,MACZ;ALyEJ,ACDA,AEGA,AE1EIpD,2BAAcb,IAAda,CAAoB0D,SAAD,IAAgBA,SAAS,GAAG,CAAC,IAAD,CAAH,GAAY,EAAxD1D,CAPiBoD;ALgFrB,ACDA;ADEA,ACDA,AIhFqBA,aAWZxE,MAXYwE,GAWFO,QAAD,IAAiB;ALuEnC,ACDA,AECEvF,AEtEE,EFsEFA,IEtEMwF,YAAY,EFsEA,CAAClJ,AEtEE,KAAnB,UFsEgB,EAA0B;AHC9C,ACDA,AECI,AEtEAsF,SFsEKtF,eAAL,GAAuBA,EEtETyE,IAAda,CAAoB0D,QFsEpB,CEtEmB,IAAe;ALuEtC,ACDA,AECG,AEtEG,QAAIE,YAAJ,EAAkB;ALuExB,ACDA,AEEE;AHAF,ACDA,AEEA,AExEM,QAAIF,SAAJ,EAAe;ALwErB,ACDA,AEEA,AExEQC,MAAAA,QAAQ,CAAC9E,IAAT8E,CAAc;ALwEtB,ACDA,AIvEwBtD,QAAAA,IAAI,EAAE,KAAR;ALyEtB,ACDA,AIxEqCnB,QAAAA,UAAU,EAAE;AL0EjD,ACDA,AEAEb,AEzEoB,EFyEpBA,KEzEMsF,yBFyEwB,CAAChJ,mBAAD,EAA8B;AHE9D,ACDA,AEAI,AEzEIgJ,MAAAA,GFyEChJ,KEzEO,CAAC0E,QAATsE,KFyEJ,GAA2BhJ,mBAA3B;AHEJ,ACDA,AEAG,AE5EG,KAAA,MAGO;AL2Eb,ACDA,AECE,AE1EMgJ,MAAAA,QAAQ,CAACvE,KAATuE,CACE,IAAIhI,sBAAJ,CACE,+CACE,4DADF,GAEE,8CAHJ,EAIE,iBAJF,CADFgI;AL2ER,ACDA,AECA,AEnEO;ALoEP,ACDA,AECA,AElFI,GAAA3D;ALmFJ,ACDA,AECA,AEnEI,SAAO;ALoEX,ACDA,AECA,AEnEMjB,IAAAA,WAAW,EAAE,MAAM;ALoEzB,ACDA,AECA,AEnEQ6E,MAAAA,YAAY,GAAG,IAAfA;ALoER,ACDA,AECA,AEnEO;ALoEP,ACDA,AECA,AEvEW,GAAP;ALwEJ,ACDA,AECA,CErGqBR;ALsGrB,ACDA,AECA;AHCA,ACDA;ADEA,ACDA,AE4BE;AH1BF,ACDA,AE4BA;AH1BA,ACDA,AE4BA;AH1BA,ACDA,AE4BA;AH1BA,ACDA,AE4BA;AH1BA,ACDA,AE4BA;AH1BA,ACDA,AE4BA;AH1BA,ACDA;ADEA,ACDA;ADEA,ACDA,AE0BE,SAAO9E,MAAP,CACEC,WAAoB,GAAG,IADzB,EAEEC,aAFF,EAGkC;AH3BpC,ACDA,AE6BI,WAAO,IAAI7B,OAAJ,CAAY,CAACc,OAAD,EAAUgB,MAAV,KAAqB;AH3B5C,ACDA,AE6BM,UAAIC,KAAK,GAAG,KAAZ;AH3BN,ACDA,AE6BM,YAAMC,GAAG,GAAG,KAAKC,MAAL,CAAY;AH3B9B,ACDA,AE6BQC,QAAAA,IAAI,EAAGC,CAAD,IAAO;AH3BrB,ACDA,AE6BUJ,UAAAA,KAAK,GAAG,IAARA;AH3BV,ACDA,AE6BU,cAAIC,GAAJ,EAASA,GAAG,CAACI,WAAJJ;AH3BnB,ACDA,AE6BU,cAAIK,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ9B;AH3B/B,ACDA,AE6BU,eAAK+B,IAAL,CAAUH,CAAC,CAACI,UAAZ,EAAwBX,WAAxB,EAAqCY,IAArC,CAA0C1B,OAA1C,EAAmDgB,MAAnD;AH3BV,ACDA,AEuB8B,SAAA;AHrB9B,ACDA,AE6BQW,QAAAA,KAAK,EAAGN,CAAD,IAAO;AH3BtB,ACDA,AE6BU,cAAIE,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ9B;AH3B/B,ACDA,AE6BUuB,UAAAA,MAAM,CAACK,CAAD,CAANL;AH3BV,ACDA,AEmB8B,SAAA;AHjB9B,ACDA,AE6BQY,QAAAA,QAAQ,EAAE,MAAM;AH3BxB,ACDA,AE6BU,cAAIL,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ9B;AH3B/B,ACDA;ADEA,ACDA,AE4BU,cAAI,CAACwB,KAAL,EAAY;AH1BtB,ACDA,AE4BYD,YAAAA,MAAM,CACJ,IAAI9C,sBAAJ,CACE,KAAK2D,0BADP,EAEE,eAFF,CADI,CAANb;AH1BZ,ACDA,AEiCW;AH/BX,ACDA,AEiCS;AH/BT,ACDA,AEW8B,OAAZ,CAAZ;AHTN,ACDA,AEiCM,YAAMO,eAAe,GAAGR,aAAa,GACjCzB,UAAU,CAAC,MAAM;AHhC3B,ACDA,AEkCY4B,QAAAA,GAAG,CAACI,WAAJJ;AHhCZ,ACDA,AEkCYF,QAAAA,MAAM,CACJ,IAAI9C,sBAAJ,CACE,KAAK4D,0BADP,EAEE,eAFF,CADI,CAANd;AHhCZ,ACDA,AE+BoB,OAAA,EAQPD,aARO,CADuB,GAUjC,IAVJ;AH5BN,ACDA,AEIW,KAAA,CAAP;AHFJ,ACDA,AEwCG;AHtCH,ACDA;ADEA,ACDA,AEwEEgB,EAAAA,qBAAqB,CACnBC,IADmB,EAEnBC,OAFmB,EAGnBC,WAHmB,EAInB;AH1EJ,ACDA,AE4EI,SAAK,IAAIC,UAAT,IAAuBF,OAAvB,EAAgC;AH1EpC,ACDA,AE4EMD,MAAAA,IAAI,CAACG,UAAD,CAAJH,GAAmB,KAAKI,oBAAL,CACjBD,UADiB,EAEjBH,IAAI,CAACG,UAAD,CAFa,EAGjBH,IAHiB,EAIjBE,WAJiB,CAAnBF;AH1EN,ACDA,AEiFK;AH/EL,ACDA,AEiFG;AH/EH,ACDA;ADEA,ACDA,AEkFEI,EAAAA,oBAAoB,CAClBD,UADkB,EAElBrD,CAFkB,EAGlBuD,GAHkB,EAIlBH,WAJkB,EAKU;AHrFhC,ACDA,AEuFI,WAAO,OAAO,GAAG3B,IAAV,KAAmB;AHrF9B,ACDA,AEuFM,YAAM;AHrFZ,ACDA,AEsFcb,QAAAA;AHpFd,ACDA,AEqFY,UAAkB,IAAxB;AHnFN,ACDA;ADEA,ACDA,AEoFM,UAAIA,WAAJ,EAAiB;AHlFvB,ACDA,AEoFQ,eAAOR,OAAO,CAAC8B,MAAR9B,CACL,IAAIhB,sBAAJ,CACE,iCAAiCwB,WAAjC,GAA+C,GADjD,EAEE,iBAFF,CADKR,CAAP;AHlFR,ACDA,AEyFO;AHvFP,ACDA;ADEA,ACDA,AEwFM,UAAI;AHtFV,ACDA,AEwFQ,aAAKQ,WAAL,GAAmByC,UAAnB;AHtFR,ACDA,AEwFQ,aAAKtC,cAAL,CAAoBqC,WAApB;AHtFR,ACDA,AEwFQ,eAAO,MAAMpD,CAAC,CAACwD,KAAFxD,CAAQuD,GAARvD,EAAayB,IAAbzB,CAAb;AHtFR,ACDA,AEoFM,OAAA,SAIU;AHtFhB,ACDA,AEwFQ,aAAKY,WAAL,GAAmB,IAAnB;AHtFR,ACDA,AEwFO;AHtFP,ACDA,AEuEI,KAAA;AHrEJ,ACDA,AEwFG;AHtFH,ACDA;ADEA,ACDA,AExM2C;AH0M3C,ACDA;ADEA,ACDA;ADEA,ACDA,AE3MqB1C,UAQXuF,WARWvF,SAAAA;AH6MrB,ACDA,AE5MqBA,UAgBXwF,IAhBWxF,SAAAA;AH8MrB,ACDA,AE7MqBA,UAsCXmE,MAtCWnE,SAAAA;AH+MrB,ACDA,AE9MqBA,UAkDXwE,IAlDWxE,SAAAA;AHgNrB,ACDA,AE/MqBA,UAgSZ8E,0BAhSY9E,GAgSiB,kCAhSjBA;AHiNrB,ACDA,AEhNqBA,UAiSZ6E,0BAjSY7E,GAiSiB,wBAjSjBA;AHkNrB,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA,ACDA;ADEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TransportU2F.e624656e.js","sourceRoot":"..\\src","sourcesContent":["// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n\n'use strict';\n\n/** Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.Request;\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.Response;\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\nu2f.RegisterRequest;\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n// Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\nu2f.disconnect = function() {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n    {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var hasCalledBack = false;\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      if (!hasCalledBack)\n      {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n\n  // Give this 200ms to initialize, after that, we treat this method as failed\n  setTimeout(function() {\n    if (!hasCalledBack)\n    {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n};\n\n\n// High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n        }\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(err, port);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function(callback) {\n  u2f.getPortSingleton_(function(err, port) {\n    callback(!err);\n  });\n}\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(registerRequests, signRequests,\n    callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n","'use strict';\n\nmodule.exports = API;\n\nvar chromeApi = require( './google-u2f-api' );\n\n// Feature detection (yes really)\nvar isBrowser = ( typeof navigator !== 'undefined' ) && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match( /Safari\\// )\n\t&& !navigator.userAgent.match( /Chrome\\// );\nvar isEDGE = isBrowser && navigator.userAgent.match( /Edge\\/1[2345]/ );\n\nvar _backend = null;\nfunction getBackend( Promise )\n{\n\tif ( !_backend )\n\t\t_backend = new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction notSupported( )\n\t\t\t{\n\t\t\t\t// Note; {native: true} means *not* using Google's hack\n\t\t\t\tresolve( { u2f: null, native: true } );\n\t\t\t}\n\n\t\t\tif ( !isBrowser )\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( isSafari )\n\t\t\t\t// Safari doesn't support U2F, and the Safari-FIDO-U2F\n\t\t\t\t// extension lacks full support (Multi-facet apps), so we\n\t\t\t\t// block it until proper support.\n\t\t\t\treturn notSupported( );\n\n\t\t\tvar hasNativeSupport =\n\t\t\t\t( typeof window.u2f !== 'undefined' ) &&\n\t\t\t\t( typeof window.u2f.sign === 'function' );\n\n\t\t\tif ( hasNativeSupport )\n\t\t\t\tresolve( { u2f: window.u2f, native: true } );\n\n\t\t\tif ( isEDGE )\n\t\t\t\t// We don't want to check for Google's extension hack on EDGE\n\t\t\t\t// as it'll cause trouble (popups, etc)\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( location.protocol === 'http:' )\n\t\t\t\t// U2F isn't supported over http, only https\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( typeof MessageChannel === 'undefined' )\n\t\t\t\t// Unsupported browser, the chrome hack would throw\n\t\t\t\treturn notSupported( );\n\n\t\t\t// Test for google extension support\n\t\t\tchromeApi.isSupported( function( ok )\n\t\t\t{\n\t\t\t\tif ( ok )\n\t\t\t\t\tresolve( { u2f: chromeApi, native: false } );\n\t\t\t\telse\n\t\t\t\t\tnotSupported( );\n\t\t\t} );\n\t\t} );\n\n\treturn _backend;\n}\n\nfunction API( Promise )\n{\n\treturn {\n\t\tisSupported   : isSupported.bind( Promise ),\n\t\tensureSupport : ensureSupport.bind( Promise ),\n\t\tregister      : register.bind( Promise ),\n\t\tsign          : sign.bind( Promise ),\n\t\tErrorCodes    : API.ErrorCodes,\n\t\tErrorNames    : API.ErrorNames\n\t};\n}\n\nAPI.ErrorCodes = {\n\tCANCELLED: -1,\n\tOK: 0,\n\tOTHER_ERROR: 1,\n\tBAD_REQUEST: 2,\n\tCONFIGURATION_UNSUPPORTED: 3,\n\tDEVICE_INELIGIBLE: 4,\n\tTIMEOUT: 5\n};\nAPI.ErrorNames = {\n\t\"-1\": \"CANCELLED\",\n\t\"0\": \"OK\",\n\t\"1\": \"OTHER_ERROR\",\n\t\"2\": \"BAD_REQUEST\",\n\t\"3\": \"CONFIGURATION_UNSUPPORTED\",\n\t\"4\": \"DEVICE_INELIGIBLE\",\n\t\"5\": \"TIMEOUT\"\n};\n\nfunction makeError( msg, err )\n{\n\tvar code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n\tvar type = API.ErrorNames[ '' + code ];\n\tvar error = new Error( msg );\n\terror.metaData = {\n\t\ttype: type,\n\t\tcode: code\n\t}\n\treturn error;\n}\n\nfunction deferPromise( Promise, promise )\n{\n\tvar ret = { };\n\tret.promise = new Promise( function( resolve, reject ) {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t\tpromise.then( resolve, reject );\n\t} );\n\t/**\n\t * Reject request promise and disconnect port if 'disconnect' flag is true\n\t * @param {string} msg\n\t * @param {boolean} disconnect\n\t */\n\tret.promise.cancel = function( msg, disconnect )\n\t{\n\t\tgetBackend( Promise )\n\t\t.then( function( backend )\n\t\t{\n\t\t\tif ( disconnect && !backend.native )\n\t\t\t\tbackend.u2f.disconnect( );\n\n\t\t\tret.reject( makeError( msg, { errorCode: -1 } ) );\n\t\t} );\n\t};\n\treturn ret;\n}\n\nfunction defer( Promise, fun )\n{\n\treturn deferPromise( Promise, new Promise( function( resolve, reject )\n\t{\n\t\ttry\n\t\t{\n\t\t\tfun && fun( resolve, reject );\n\t\t}\n\t\tcatch ( err )\n\t\t{\n\t\t\treject( err );\n\t\t}\n\t} ) );\n}\n\nfunction isSupported( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\treturn !!backend.u2f;\n\t} );\n}\n\nfunction _ensureSupport( backend )\n{\n\tif ( !backend.u2f )\n\t{\n\t\tif ( location.protocol === 'http:' )\n\t\t\tthrow new Error( \"U2F isn't supported over http, only https\" );\n\t\tthrow new Error( \"U2F not supported\" );\n\t}\n}\n\nfunction ensureSupport( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( _ensureSupport );\n}\n\nfunction register( registerRequests, signRequests /* = null */, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( registerRequests ) )\n\t\tregisterRequests = [ registerRequests ];\n\n\tif ( typeof signRequests === 'number' && typeof timeout === 'undefined' )\n\t{\n\t\ttimeout = signRequests;\n\t\tsignRequests = null;\n\t}\n\n\tif ( !signRequests )\n\t\tsignRequests = [ ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = registerRequests[ 0 ].appId;\n\n\t\t\t\tu2f.register(\n\t\t\t\t\tappId, registerRequests, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.register(\n\t\t\t\t\tregisterRequests, signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction sign( signRequests, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( signRequests ) )\n\t\tsignRequests = [ signRequests ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = signRequests[ 0 ].appId;\n\t\t\t\tvar challenge = signRequests[ 0 ].challenge;\n\n\t\t\t\tu2f.sign( appId, challenge, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.sign( signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction makeDefault( func )\n{\n\tAPI[ func ] = function( )\n\t{\n\t\tif ( !global.Promise )\n\t\t\t// This is very unlikely to ever happen, since browsers\n\t\t\t// supporting U2F will most likely support Promises.\n\t\t\tthrow new Error( \"The platform doesn't natively support promises\" );\n\n\t\tvar args = [ ].slice.call( arguments );\n\t\treturn API( global.Promise )[ func ].apply( null, args );\n\t};\n}\n\n// Provide default functions using the built-in Promise if available.\nmakeDefault( 'isSupported' );\nmakeDefault( 'ensureSupport' );\nmakeDefault( 'register' );\nmakeDefault( 'sign' );\n","'use strict';\nmodule.exports = require( './lib/u2f-api' );","//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage,\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device,\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed,\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n  unresponsiveTimeout: number = 15000;\n  deviceModel: ?DeviceModel = null;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data,\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some((s) => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: (e) => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: (e) => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async (f) => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n    let resolveBusy;\n    const busyPromise = new Promise((r) => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n","// @flow\n\n/**\n * A Log object\n */\nexport type Log = {\n  type: string,\n  message?: string,\n  data?: any,\n  id: string, // unique amount all logs\n  date: Date, // date of the log\n};\n\nexport type Unsubscribe = () => void;\n\nlet id = 0;\nconst subscribers = [];\n\n/**\n * log something\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: string, message?: string, data?: any) => {\n  const obj: Log = { type, id: String(++id), date: new Date() };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * listen to logs.\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: (Log) => void): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n","//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"]}